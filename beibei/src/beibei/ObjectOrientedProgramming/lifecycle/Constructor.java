package beibei.ObjectOrientedProgramming.lifecycle;

/**
 * Created by sunyinhui on 16-6-7.
 */

/**
 * 构造方法
 * 构造方法必须满足以下语法规则
 *      1. 方法名必须与类同名
 *      2. 不要声明返回类型
 *      3. 不能被static,final,synchronized,abstract,native修饰。
 *         构造方法不能被子类继承，所以用final和abstract修饰没有意义。
 *
 *
 */

/**
 * this语句来调用其他构造方法时，必须遵循以下语法规则
 *      1. 如果在一个构造方法中使用了this语句，那么必须作为构造方法的第一条语句，不考虑注释语句
 *      2. 只能在构造方法中使用this语句来调用类的其他构造方法，而不能在实例方法中用this语句来调用类的其他构造方法
 *      3. 只能用this语句来调用其他构造方法，而不能通过方法名来直接调用构造方法
 */

/**
 * 父类的构造方法不能被子类继承
 * 在子类的构造方法中，可以通过super语句调用父类的构造方法，而它必须作为构造方法的第一条语句
 * 在构建子类的对象时，Java虚拟机首先执行父类的构造方法，然后再执行子类的构造方法
 */

/**
 * 构造方法的访问级别
 * 构造方法处于public,protected,private和default四种访问级别。
 * 当构造方法为private级别时，意味着只能在当前类中访问它：在当前类的其他构造方法中可以通过this语句调用它
 * 此外还可以在当前类的成员方法中通过new语句调用它
 */

/**
 * 在以下场合之一，可以把类的所有构造方法都声明为private类型
 * 1.   在这个类中仅仅包含了一些所能供其他程序调用的静态方法，没有任何实例方法。
 *      其他程序无须创建该类的实例，就能访问类的静态方法。例如java.lang.Math类就符合这种情况。
 *      在Math类中提供了一系列用于数学运算的公共的静态方法，为了禁止外部程序创建Math类的实例，
 *      Math类的唯一的构造方法是private类型的。
 * 2.   禁止这个类被继承。当一个类的所有构造方法都是private类型的时，假如定义了它的子类，那么子类的
 *      构造方法无法调用父类的任何构造方法，因此会导致编译错误。
 *      把一个类声明为final类型，也能禁止这个类被继承，这两者的区别是：
 *          a.如果一个类允许其他程序用new语句构造它的实例，但不允许拥有子类，那么就把类声明为final类型
 *          b.如果一个类既不允许其他程序用new语句构造它的实例，又不允许拥有子类，那么就把类的所有构造方法声明为private类型。
 *      由于大多数类都允许其他程序用new语句构造它的实例，因此用final修饰符来禁止类被继承的做法更常见。
 * 3.   这个类需要把构造自身实例的细节封装起来，不允许其他程序通过new语句创建这个类的实例。
 *      这个类向其他程序提供了获得自身实例的静态方法，这种方法称为静态工厂方法。
 *
 *
 *
 */

public class Constructor {
}






























