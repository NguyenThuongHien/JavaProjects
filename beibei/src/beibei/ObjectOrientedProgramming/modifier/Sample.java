package beibei.ObjectOrientedProgramming.modifier;

/**
 * Created by sunyinhui on 16-6-5.
 */

/**
 * 成员方法分为静态方法和实例方法
 * 用static修饰的方法叫静态方法，或类方法
 * 静态方法也和静态变量一样，不需要创建类的实例，可以通过类名来访问
 */

/**
 * 静态方法不需要通过它所属的类的任何实例就会被调用，因此在静态方法中不能使用this关键字
 * 也不能直接访问所属类的实例变量和实例方法，可以直接访问所属类的静态变量和静态方法
 */

/**
 * 实例方法可访问的内容
 * 如果一个方法没有用static修饰，那么它就是实例方法
 * 在实例方法中可以直接访问所属类的静态变量、静态方法、实例变量和实例方法
 */

/**
 * 静态方法必须被实现
 * 静态方法用来表示某个类所特有的功能，这种功能的实现不依赖于类的具体实例，也不依赖于它的子类
 * 当前类必须为静态方法提供实现，一个静态的方法不能被定义为抽象方法
 * static和abstract不能一起使用，如果一个方法是静态的，它就必须自力更生，自己实现该方法
 * 如果一个方法是抽象的，那么它就只能表示类所具有的功能，但不实现它，在子类中才会实现它
 */
public class Sample {

    /**
     * main()方法用static修饰，可以使得Java虚拟机只要加载了main()方法所属的类，就能执行main()方法
     * 而无需先创建这个类的实例
     */
    int x ;
    public static void main(String[] args){
    //  x = 9;
    /**
     * 在main()静态方法中不能直接访问实例变量和实例方法。
     */

        Sample sample = new Sample();

    }

    /**
     * 在静态代码块中，也不能访问类的实例的变量和实例方法，而必须通过实例的引用来访问它们。
     */
    static {
        System.out.println("static block");
    }

    public Sample() {
        System.out.println("constructor");;
    }
}
/**
 * static静态块
 *    它不存在于任何方法体中，在Java虚拟机加载类时会执行这些静态代码块，如果类中包含多个静态块，
 *    那么Java虚拟机将按照它们在类中出现的顺序依次执行它们。每个静态代码块只会执行一次。
 *
 */